#!/usr/bin/env python3

# Copyright (c) 2015, Robert Escriva
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of this project nor the names of its contributors may
#       be used to endorse or promote products derived from this software
#       without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import argparse
import errno
import os
import os.path
import pipes
import re
import shlex
import shutil
import signal
import subprocess
import sys
import tempfile
import time

class GremlinError(Exception): pass

def sanitized_shell(cmd):
    return ' '.join([pipes.quote(c) for c in cmd])

class Parser(object):

    def __init__(self, path):
        self.path = path
        self.init = False
        self.cmds = None

    def parse(self, reparse=False):
        def gen(cmds):
            for cmd in cmds:
                yield cmd
        if self.init and not reparse:
            assert self.cmds is not None
            return gen(self.cmds)
        if not os.path.exists(self.path):
            raise GremlinError('no such file %r' % self.path)
        s = shlex.shlex(open(self.path, 'r'), self.path, posix=True)
        s.whitespace = ' \t\r'
        s.wordchars += '!#$%&()*+,-./:<=>?@[\\]^_`{|}~'
        s.source = 'include'
        cmds = []
        cmd = []
        while True:
            x = s.get_token()
            if x is s.eof:
                cmds.append(cmd)
                break
            if x in (';', '\n'):
                cmds.append(cmd)
                cmd = []
            else:
                cmd.append(x)
        cmds = [tuple(cmd) for cmd in cmds if cmd]
        return cmds

class Playground(object):

    def __init__(self, path):
        self.parser = Parser(path)
        self.environment = {}
        self.base = tempfile.mkdtemp(prefix='gremlin-')
        self.crash_is_nop = False
        self.daemons = []
        self.timeout = None
        self.failed = False
        self.execed = 0
        self.exit = 0
        os.mkdir(os.path.join(self.base, '.gremlin'))

    def run(self):
        for cmd in self.parser.parse():
            assert cmd
            self.get_cmd(cmd[0])
        try:
            for cmd in self.parser.parse():
                f = self.get_cmd(cmd[0])
                f(cmd[1:])
                if self.failed:
                    break
            self.clean()
        finally:
            self.crash()

    def daemons_all_dead(self):
        return not any([d.returncode is None for d in self.daemons])

    def clean(self):
        count = 0
        dump_logs = self.failed
        for proc in self.daemons:
            if proc.poll() is not None and proc.returncode != 0:
                dump_logs = True
        while count < 16 and not self.daemons_all_dead():
            for proc in reversed(self.daemons):
                if proc.returncode is None and proc.poll() is None:
                    pid = proc.pid
                    assert pid > 0
                    if count >= 15:
                        os.kill(pid, signal.SIGKILL)
                    else:
                        os.kill(pid, signal.SIGTERM)
            count += 1
            time.sleep(0.1 * count)
        for proc in self.daemons:
            if proc.returncode is None:
                proc.poll()
        if not self.daemons_all_dead():
            raise GremlinError("could not clean up all daemons")
        self.crash_is_nop = True
        for proc in self.daemons:
            proc.wait()
        if dump_logs:
            print('the gremlins were kind enough to provide log files')
            print('playground: %s' % self.base)
            if self.daemons:
                print()
            for idx, proc in enumerate(self.daemons):
                print('daemon[%d]: %s' % (idx, sanitized_shell(proc.cmd)))
                print('exited %d' % proc.returncode)
                output = open(self.daemon_logfile(idx), 'r').read()
                output = output.strip()
                if output:
                    print('stdout/stderr (merged):')
                    print(output)
                if idx + 1 < len(self.daemons):
                    print()
            self.exit = 1
        else:
            shutil.rmtree(self.base)
            self.exit = 0

    def crash(self):
        if self.crash_is_nop:
            return
        for proc in reversed(self.daemons):
            if proc.poll() is None:
                proc.kill()
            proc.wait()

    def get_cmd(self, cmd):
        orig = cmd
        cmd = 'cmd_' + cmd.replace('-', '_')
        if not hasattr(self, cmd):
            raise GremlinError('unknown command: %r' % orig)
        return getattr(self, cmd)

    def cmd_env(self, cmd):
        if len(cmd) == 1:
            self.environment[cmd[0]] = ''
        elif len(cmd) == 2:
            self.environment[cmd[0]] = cmd[1]
        else:
            raise GremlinError('invalid environment: %s' % sanitized_shell(cmd))

    def cmd_timeout(self, cmd):
        if len(cmd) == 0:
            self.timeout = None
        elif len(cmd) == 1:
            try:
                self.timeout = int(cmd[0])
            except ValueError:
                raise GremlinError('invalid timeout: %s' % sanitized_shell(cmd))
        else:
            raise GremlinError('invalid timeout: %s' % sanitized_shell(cmd))

    def cmd_run(self, cmd):
        try:
            cmd = tuple(map(os.path.expandvars, cmd))
            p = subprocess.Popen(cmd, cwd=self.base,
                                 stdout=subprocess.PIPE,
                                 stderr=subprocess.STDOUT)
            try:
                stdout, stderr = p.communicate(timeout=self.timeout)
            except subprocess.TimeoutExpired:
                print('timeout %ds exceeded: %s' % (self.timeout, sanitized_shell(cmd)))
                p.kill()
                stdout, stderr = p.communicate()
            if p.returncode != 0:
                self.failed = True
                print('exited %d: %s' % (p.returncode, sanitized_shell(cmd)))
                stdout = stdout.decode('utf8', 'ignore').strip()
                if stdout:
                    print('stdout/stderr (merged):')
                    print(stdout)
        except OSError as e:
            if e.errno == errno.ENOENT:
                raise GremlinError('ENOENT: %s' % sanitized_shell(cmd))
            raise e

    def cmd_tcp_port(self, cmd):
        ports = set()
        for p in cmd:
            try:
                p = int(p, 10)
                ports.add(p)
            except ValueError:
                raise GremlinError('invalid port: %s' % p)
        states = {}
        wait = True
        iteration = 0
        while wait:
            wait = False
            stdout = subprocess.check_output(('netstat', '-an'))
            stdout = stdout.decode('utf8', 'ignore')
            for x in re.findall('^tcp.*$', stdout, flags=re.MULTILINE):
                x = re.sub('\s+', ' ', x).split(' ')
                port = x[3].rsplit(':', 1)[-1]
                try:
                    port = int(port, 10)
                except ValueError:
                    raise GremlinError('error parsing netstat output')
                state = x[5]
                states[port] = state
                if port in ports and state != 'TIME_WAIT':
                    wait = True
            if wait and all([x in ('LISTEN', 'ESTABLISHED') for x in list(states.values())]):
                raise GremlinError('ports in use by other processes')
            if wait:
                time.sleep(0.1)
            iteration += 1
            if iteration >= 100:
                raise GremlinError('ports in use by other processes')

    def daemon_logfile(self, idx):
        return os.path.join(self.base, '.gremlin', 'daemon %d.log' % idx)

    def cmd_daemon(self, cmd):
        env = dict(os.environ)
        env.update(self.environment)
        stdout = open(self.daemon_logfile(len(self.daemons)), 'w')
        try:
            proc = subprocess.Popen(cmd, stdout=stdout, stderr=subprocess.STDOUT,
                                    env=env, cwd=self.base)
        except OSError as e:
            if e.errno == errno.ENOENT:
                raise GremlinError('ENOENT: %s' % sanitized_shell(cmd))
            raise e
        proc.cmd = cmd
        self.daemons.append(proc)

    def cmd_kill(self, cmd):
        if len(cmd) != 2:
            raise GremlinError('invalid kill command: must be <signal> <daemon>')
        try:
            daemon = int(cmd[1], 10)
        except ValueError:
            raise GremlinError('daemon to kill must be a non-zero number')
        if daemon < 0:
            raise GremlinError('daemon to kill must be a non-zero number')
        if daemon >= len(self.daemons):
            raise GremlinError('daemon to kill must have been spawned first')
        sig = getattr(signal, 'SIG' + cmd[0], getattr(signal, cmd[0], None))
        if sig is None:
            raise GremlinError('unknown signal: %r' % cmd[0])
        daemon = self.daemons[daemon]
        daemon.send_signal(sig)

def main(todo):
    try:
        p = Playground(todo)
        p.run()
        sys.exit(p.exit)
    except GremlinError as e:
        print(str(e), file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('file', help='instructions for the gremlin')
    args = parser.parse_args()
    main(args.file)
